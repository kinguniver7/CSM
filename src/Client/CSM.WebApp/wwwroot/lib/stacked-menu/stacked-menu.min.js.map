{"version":3,"file":"stacked-menu.min.js","sources":["src/scripts/stacked-menu.js"],"sourcesContent":["/**\n * A flexible stacked navigation menu.\n * @class\n *\n * @example <caption>The StackedMenu basic template looks like:</caption>\n * <div id=\"stacked-menu\" class=\"stacked-menu\">\n *   <nav class=\"menu\">\n *     <li class=\"menu-item\">\n *      <a href=\"home.html\" class=\"menu-link\">\n *        <i class=\"menu-icon fa fa-home\"></i>\n *        <span class=\"menu-text\">Home</span>\n *        <span class=\"badge badge-danger\">9+</span>\n *      </a>\n *     <li>\n *   </nav>\n * </div>\n *\n * @example <caption>Instance the StackedMenu:</caption>\n * var menus = new StackedMenu();\n */\nclass StackedMenu {\n\n  /**\n   * Create a StackedMenu.\n   * @constructor\n   * @param  {Object} options - An object containing key:value that representing the current StackedMenu.\n   */\n  constructor(options) {\n    /**\n     * The StackedMenu options.\n     * @type {Object}\n     * @property {Boolean} compact=false                  - Transform StackedMenu items (except item childs) to small size.\n     * @property {Boolean} hoverable=false                - How StackedMenu triggered `open`/`close` state. Use `false` for hoverable and `true` for collapsible (clickable).\n     * @property {Boolean} closeOther=true                - Control whether expanding an item will cause the other items to close. Only available when `hoverable=false`.\n     * @property {String} align='left'                    - Where StackedMenu items childs will open when `hoverable=true` (`left`/`right`).\n     * @property {String} selector='#stacked-menu'        - The StackedMenu element selector.\n     * @property {String} selectorClass='stacked-menu'    - The css class name that will be added to the StackedMenu and used for css prefix classes.\n     * @example\n     * var options = {\n     *   closeOther: false,\n     *   align: 'right',\n     * };\n     *\n     * var menus = new StackedMenu(options);\n     */\n    this.options = {\n      compact: false,\n      hoverable: false,\n      closeOther: true,\n      align: 'right',\n      selector: '#stacked-menu',\n      selectorClass: 'stacked-menu'\n    }\n\n    // mixed default and custom options\n    this.options = this._extend({}, this.options, options)\n\n    /**\n     * The StackedMenu element.\n     * @type {Element}\n     */\n    this.selector = document.querySelector(this.options.selector)\n\n    /**\n     * The StackedMenu items.\n     * @type {Element}\n     */\n    this.items = this.selector ? this.selector.querySelectorAll('.menu-item') : null\n\n    // forEach fallback\n    if (!Array.prototype.forEach) {\n      Array.prototype.forEach = function forEach(cb, arg) {\n        if(typeof cb !== 'function') throw new TypeError(`${cb} is not a function`)\n\n        let array = this\n        arg = arg || this\n        for(let i = 0; i < array.length; i++) {\n          cb.call(arg, array[i], i, array)\n        }\n      }\n    }\n    this.each = Array.prototype.forEach\n\n    /**\n     * Lists of feature classes that will be added to the StackedMenu depend to current options.\n     * Used selectorClass for prefix.\n     * @type {Object}\n     */\n    this.classes = {\n      alignLeft: this.options.selectorClass + '-has-left',\n      compact: this.options.selectorClass + '-has-compact',\n      collapsible: this.options.selectorClass + '-has-collapsible',\n      hoverable: this.options.selectorClass + '-has-hoverable',\n      hasChild: 'has-child',\n      hasActive: 'has-active',\n      hasOpen: 'has-open'\n    }\n\n    /** states element */\n    /**\n     * The active item.\n     * @type {Element}\n     */\n    this.active = null\n\n    /**\n     * The open item(s).\n     * @type {Element}\n     */\n    this.open = []\n\n    /** event handlers */\n    this.handlerClickDoc = []\n    this.handlerOver = []\n    this.handlerOut = []\n    this.handlerClick = []\n\n    // Initialization\n    this.init()\n  }\n\n  /** Private methods */\n  /**\n   * Listen on document when the page is ready.\n   * @private\n   * @param  {Function} handler - The callback function when page is ready.\n   * @return {void}\n   */\n  _onReady(handler) {\n    if(document.readyState != 'loading') {\n      handler()\n    } else {\n      document.addEventListener('DOMContentLoaded', handler, false)\n    }\n  }\n\n  /**\n   * Merge the contents of two or more objects together into the first object.\n   * @private\n   * @param  {Object} obj - An object containing additional properties to merge in.\n   * @return {Object} The merged object.\n   */\n  _extend(obj) {\n    obj = obj || {}\n    const args = arguments\n    for (let i = 1; i < args.length; i++) {\n      if (!args[i]) continue\n      for (let key in args[i]) {\n        if (args[i].hasOwnProperty(key))\n          obj[key] = args[i][key]\n      }\n    }\n    return obj\n  }\n\n  /**\n   * Attach an event to StackedMenu selector.\n   * @private\n   * @param  {String} type - The name of the event (case-insensitive).\n   * @param  {(Boolean|Number|String|Array|Object)} data - The custom data that will be added to event.\n   * @return {void}\n   */\n  _emit(type, data) {\n    let e\n    if (document.createEvent) {\n      e = document.createEvent('Event')\n      e.initEvent(type, true, true)\n    } else {\n      e = document.createEventObject()\n      e.eventType = type\n    }\n    e.eventName = type\n    e.data = data || this\n    // attach event to selector\n    document.createEvent\n      ? this.selector.dispatchEvent(e)\n      : this.selector.fireEvent('on' + type, e)\n  }\n\n  /**\n   * Bind one or two handlers to the element, to be executed when the mouse pointer enters and leaves the element.\n   * @private\n   * @param  {Element} el - The target element.\n   * @param  {Function} handlerOver - A function to execute when the mouse pointer enters the element.\n   * @param  {Function} handlerOut  - A function to execute when the mouse pointer leaves the element.\n   * @return {void}\n   */\n  _hover(el, handlerOver, handlerOut) {\n    if (el.tagName === 'A') {\n      this._on(el, 'focus', handlerOver)\n      this._on(el, 'blur', handlerOut)\n    } else {\n      this._on(el, 'mouseover', handlerOver)\n      this._on(el, 'mouseout', handlerOut)\n    }\n  }\n\n  /**\n   * Registers the specified listener on the element.\n   * @private\n   * @param  {Element} el - The target element.\n   * @param  {String} type - The name of the event.\n   * @param  {Function} handler - The callback function when event type is fired.\n   * @return {void}\n   */\n  _on(el, type, handler) {\n    let types = type.split(' ')\n    for (let i = 0; i < types.length; i++) {\n      el[window.addEventListener ? 'addEventListener' : 'attachEvent']( window.addEventListener ? types[i] : `on${types[i]}` , handler, false)\n    }\n  }\n\n  /**\n   * Removes the event listener previously registered with [_on()]{@link StackedMenu#_on} method.\n   * @private\n   * @param  {Element} el - The target element.\n   * @param  {String} type - The name of the event.\n   * @param  {Function} handler - The callback function when event type is fired.\n   * @return {void}\n   */\n  _off(el, type, handler) {\n    let types = type.split(' ')\n    for (let i = 0; i < types.length; i++) {\n      el[window.removeEventListener ? 'removeEventListener' : 'detachEvent']( window.removeEventListener ? types[i] : `on${types[i]}` , handler, false)\n    }\n  }\n\n  /**\n   * Adds one or more class names to the target element.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {String} className - Specifies one or more class names to be added.\n   * @return {void}\n   */\n  _addClass(el, className) {\n    let classes = className.split(' ')\n    for (let i = 0; i < classes.length; i++) {\n      if (el.classList) el.classList.add(classes[i])\n      else el.classes[i] += ' ' + classes[i]\n    }\n  }\n\n  /**\n   * Removes one or more class names to the target element.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {String} className - Specifies one or more class names to be added.\n   * @return {void}\n   */\n  _removeClass(el, className) {\n    let classes = className.split(' ')\n    for (let i = 0; i < classes.length; i++) {\n      if (el.classList) el.classList.remove(classes[i])\n      else el.classes[i] = el.classes[i].replace(new RegExp('(^|\\\\b)' + classes[i].split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ')\n    }\n  }\n\n  /**\n   * Determine whether the element is assigned the given class.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {String} className - The class name to search for.\n   * @return {Boolean} is has className.\n   */\n  _hasClass(el, className) {\n    if (el.classList) return el.classList.contains(className)\n    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className)\n  }\n\n  /**\n   * Determine whether the element is a menu child.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is has child.\n   */\n  _hasChild(el) {\n    return this._hasClass(el, this.classes.hasChild)\n  }\n\n  /**\n   * Determine whether the element is a active menu.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is has active state.\n   */\n  _hasActive(el) {\n    return this._hasClass(el, this.classes.hasActive)\n  }\n\n  /**\n   * Determine whether the element is a open menu.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is has open state.\n   */\n  _hasOpen(el) {\n    return this._hasClass(el, this.classes.hasOpen)\n  }\n\n  /**\n   * Determine whether the element is a level menu.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is a level menu.\n   */\n  _isLevelMenu (el) {\n    return this._hasClass(el.parentNode.parentNode, this.options.selectorClass)\n  }\n\n  /**\n   * Attach an event to menu item depend on hoverable option.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {Number} index - An array index from each menu item use to detach the current event.\n   * @return {void}\n   */\n  _menuTrigger(el, index) {\n    let elHover = el.querySelector('a')\n\n    // remove exist listener\n    this._off(el, 'mouseover', this.handlerOver[index])\n    this._off(el, 'mouseout', this.handlerOut[index])\n    this._off(elHover, 'focus', this.handlerOver[index])\n    this._off(elHover, 'blur', this.handlerOut[index])\n    this._off(el, 'click', this.handlerClick[index])\n\n    // handler listener\n    this.handlerOver[index] = this.openMenu.bind(this, el)\n    this.handlerOut[index] = this.closeMenu.bind(this, el)\n    this.handlerClick[index] = this.toggleMenu.bind(this, el)\n\n    // add listener\n    if (this.isHoverable()) {\n      if (this._hasChild(el)) {\n        this._hover(el, this.handlerOver[index], this.handlerOut[index])\n        this._hover(elHover, this.handlerOver[index], this.handlerOut[index])\n      }\n    } else {\n      this._on(el, 'click', this.handlerClick[index])\n    }\n  }\n\n  /**\n   * Handle for menu items interactions.\n   * @private\n   * @param {Element} items - The element of menu items.\n   * @return {void}\n   */\n  _handleInteractions(items) {\n    const self = this\n\n    this.each.call(items, (el, i) => {\n      if (self._hasChild(el)) {\n        self._menuTrigger(el, i)\n      }\n\n      if(self._hasActive(el)) self.active =  el\n    })\n  }\n\n  /**\n   * Get the parent menu item text of menu to be use on menu subhead.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {void}\n   */\n  _getSubhead(el) {\n    return el.querySelector('.menu-text').textContent\n  }\n\n  /**\n   * Generate the subhead element for each child menu.\n   * @private\n   * @return {void}\n   */\n  _generateSubhead() {\n    const self = this\n    let menus = this.selector.children\n    let link, menu, subhead, label\n    this.each.call(menus, el => {\n      self.each.call(el.children, child => {\n        if (self._hasChild(child)) {\n          self.each.call(child.children, cc => {\n            if(self._hasClass(cc, 'menu-link')) link = cc\n          })\n\n          menu = link.nextElementSibling\n          subhead = document.createElement('li')\n          label = document.createTextNode(self._getSubhead(link))\n          subhead.appendChild(label)\n          self._addClass(subhead, 'menu-subhead')\n\n          menu.insertBefore(subhead, menu.firstChild)\n        }\n      })\n    })\n  }\n\n  /**\n   * Handle menu link tabindex depend on parent states.\n   * @return {void}\n   */\n  _handleTabIndex () {\n    const self = this\n    this.each.call(this.items, el => {\n      let container = el.parentNode.parentNode\n      if (!self._isLevelMenu(el)) {\n        el.querySelector('a').setAttribute('tabindex', '-1')\n      }\n      if (self._hasActive(container) || self._hasOpen(container)) {\n        el.querySelector('a').removeAttribute('tabindex')\n      }\n    })\n  }\n\n  /**\n   * Animate slide menu item.\n   * @private\n   * @param  {Object} el - The target element.\n   * @param  {String} direction - Up/Down slide direction.\n   * @param  {Number} speed - Animation Speed in millisecond.\n   * @param  {String} easing - CSS Animation effect.\n   * @return {Promise} resolve\n   */\n  _slide(el, direction, speed, easing) {\n    speed = speed || 300\n    easing = easing || 'ease'\n    let self = this\n    let menu = el.querySelector('.menu')\n    let es = window.getComputedStyle(el)['height']\n    // wait to resolve\n    let walkSpeed = speed + 50\n    // wait to clean style attribute\n    let clearSpeed = walkSpeed + 100\n\n    menu.style.transition = `height ${speed}ms ${easing}, opacity ${speed/2}ms ${easing}, visibility ${speed/2}ms ${easing}`\n\n    // slideDown\n    if (direction === 'down') {\n      // element\n      el.style.overflow = 'hidden'\n      el.style.height = es\n      // menu\n      menu.style.height = 'auto'\n      // get the current menu height\n      let height = window.getComputedStyle(menu)['height']\n      menu.style.height = 0\n      menu.style.visibility = 'hidden'\n      menu.style.opacity = 0\n      // remove element style\n      el.style.overflow = ''\n      el.style.height = ''\n\n      setTimeout(function() {\n        menu.style.height = height\n        menu.style.opacity = 1\n        menu.style.visibility = 'visible'\n      }, 0)\n    } else if (direction === 'up') {\n      // get the menu height\n      let height = window.getComputedStyle(menu)['height']\n      menu.style.height = height\n      menu.style.visibility = 'visible'\n      menu.style.opacity = 1\n\n      setTimeout(function() {\n        menu.style.height = 0\n        menu.style.visibility = 'hidden'\n        menu.style.opacity = 0\n      }, 0)\n    }\n\n    let done = new Promise(function(resolve) {\n      // remove the temporary styles\n      setTimeout(function() {\n        resolve(el)\n        // emit event\n        self._emit('menu:slide' + direction)\n      }, walkSpeed)\n    })\n\n    // remove styles after done has resolve\n    setTimeout(function() {\n      menu.removeAttribute('style')\n    }, clearSpeed)\n\n    return done\n  }\n\n  /** Public methods */\n  /**\n   * The first process that called after constructs the StackedMenu instance.\n   * @public\n   * @fires StackedMenu#menu:init\n   * @return {void}\n   */\n  init() {\n    const self = this\n    let opts = this.options\n\n    this._addClass(this.selector, opts.selectorClass)\n\n    // generate subhead\n    this._generateSubhead()\n\n    // implement compact feature\n    this.compact(opts.compact)\n    // implement hoverable feature\n    this.hoverable(opts.hoverable)\n\n    // handle menu link tabindex\n    this._handleTabIndex()\n\n    this.each.call(this.items, (el) => {\n      // stop propagation on each menu-link\n      self._on(el, 'click', function(e) {\n        e.stopPropagation()\n        // prevent default if has child\n        if (self._hasChild(el)) e.preventDefault()\n      })\n    })\n\n    // close on outside click, only on collapsible with compact mode\n    this._on(document.body, 'click', function () {\n      if (!self.isHoverable() && self.isCompact()) {\n        // handle listener\n        self.closeAllMenu()\n      }\n    })\n\n    // on ready state\n    this._onReady(() => {\n\n      /**\n       * This event is fired when the Menu has completed init.\n       *\n       * @event StackedMenu#menu:init\n       * @type {Object}\n       * @property {Object} data - The StackedMenu data instance.\n       *\n       * @example\n       * document.querySelector('#stacked-menu').addEventListener('menu:init', function(e) {\n       *   console.log(e.data);\n       * });\n       * @example <caption>Or using jQuery:</caption>\n       * $('#stacked-menu').on('menu:init', function() {\n       *   console.log('fired on menu:init!!');\n       * });\n       */\n      self._emit('menu:init')\n    })\n  }\n\n  /**\n   * Open/show the target menu item. This method didn't take effect to an active item if not on compact mode.\n   * @public\n   * @fires StackedMenu#menu:open\n   * @param {Element} el - The target element.\n   * @param {Boolean} emiter - are the element will fire menu:open or not.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * var menuItem2 = menu.querySelectorAll('.menu-item.has-child')[1];\n   * menu.openMenu(menuItem2);\n   */\n  openMenu(el, emiter = true) {\n    // prevent open on active item if not on compact mode\n    if(this._hasActive(el) && !this.isCompact()) return\n    const self = this\n    let blockedSlide = this._isLevelMenu(el) && this.isCompact()\n\n    // open menu\n    if (this.isHoverable() || blockedSlide) {\n      this._addClass(el, this.classes.hasOpen)\n      // handle tabindex\n      this._handleTabIndex()\n    } else {\n      // slide down\n      this._slide(el, 'down', 150, 'linear').then(function() {\n        self._addClass(el, self.classes.hasOpen)\n        // handle tabindex\n        self._handleTabIndex()\n      })\n    }\n\n    this.open.push(el)\n\n    // child menu behavior\n    if (this.isHoverable() || (this.isCompact() && !this.hoverable())) {\n      const clientHeight = document.documentElement.clientHeight\n      const child = el.querySelector('.menu')\n      const pos = child.getBoundingClientRect()\n      const tolerance = pos.height - 20\n      const bottom = clientHeight - pos.top\n      const transformOriginX = this.options.align === 'left' ? '100%' : '0px'\n\n      if (pos.top >= 500 || tolerance >= bottom) {\n        child.style.top = 'auto'\n        child.style.bottom = 0\n        child.style.transformOrigin = `${transformOriginX} 100% 0`\n      }\n    }\n\n    /**\n     * This event is fired when the Menu has open.\n     *\n     * @event StackedMenu#menu:open\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:open', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:open', function() {\n     *   console.log('fired on menu:open!!');\n     * });\n     */\n    if (emiter) {\n      this._emit('menu:open')\n    }\n\n    return this\n  }\n\n  /**\n   * Close/hide the target menu item.\n   * @public\n   * @fires StackedMenu#menu:close\n   * @param {Element} el - The target element.\n   * @param {Boolean} emiter - are the element will fire menu:open or not.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * var menuItem2 = menu.querySelectorAll('.menu-item.has-child')[1];\n   * menu.closeMenu(menuItem2);\n   */\n  closeMenu(el, emiter = true) {\n    const self = this\n    let blockedSlide = this._isLevelMenu(el) && this.isCompact()\n    // open menu\n    if (this.isHoverable() || blockedSlide) {\n      this._removeClass(el, this.classes.hasOpen)\n      // handle tabindex\n      this._handleTabIndex()\n    } else {\n      if (!this._hasActive(el)) {\n        // slide up\n        this._slide(el, 'up', 150, 'linear').then(function() {\n          self._removeClass(el, self.classes.hasOpen)\n          // handle tabindex\n          self._handleTabIndex()\n        })\n      }\n    }\n\n    this.each.call(this.open, (v, i) => {\n      if (el == v) self.open.splice(i, 1)\n    })\n\n    // remove child menu behavior style\n    if (this.isHoverable() || (this.isCompact() && !this.hoverable())) {\n      const child = el.querySelector('.menu')\n\n      child.style.top = ''\n      child.style.bottom = ''\n      child.style.transformOrigin = ''\n    }\n\n    /**\n     * This event is fired when the Menu has close.\n     *\n     * @event StackedMenu#menu:close\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:close', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:close', function() {\n     *   console.log('fired on menu:close!!');\n     * });\n     */\n    if (emiter) {\n      this._emit('menu:close')\n    }\n\n    return this\n  }\n\n  /**\n   * Close all opened menu items.\n   * @public\n   * @fires StackedMenu#menu:close\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.closeAllMenu();\n   */\n  closeAllMenu() {\n    const self = this\n    this.each.call(this.items, el => {\n      if (self._hasOpen(el)) {\n        self.closeMenu(el, false)\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Toggle open/close the target menu item.\n   * @public\n   * @fires StackedMenu#menu:open\n   * @fires StackedMenu#menu:close\n   * @param {Element} el - The target element.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * var menuItem2 = menu.querySelectorAll('.menu-item.has-child')[1];\n   * menu.toggleMenu(menuItem2);\n   */\n  toggleMenu(el) {\n    const method = this._hasOpen(el) ? 'closeMenu': 'openMenu'\n    const self = this\n    let itemParent, elParent\n\n    // close other\n    this.each.call(this.items, item => {\n      itemParent = item.parentNode.parentNode\n      elParent = el.parentNode.parentNode\n      // close other except parents that has open state and an active item\n      if(!self._hasOpen(elParent) && self._hasChild(itemParent)) {\n        if (self.options.closeOther || (!self.options.closeOther && self.isCompact())) {\n          if (self._hasOpen(itemParent)) {\n            self.closeMenu(itemParent, false)\n          }\n        }\n      }\n    })\n    // open target el\n    if (this._hasChild(el)) this[method](el)\n\n    return this\n  }\n\n  /**\n   * Set the open menu position to `left` or `right`.\n   * @public\n   * @fires StackedMenu#menu:align\n   * @param  {String} position - The position that will be set to the Menu.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.align('left');\n   */\n  align(position) {\n    const method = (position === 'left') ? '_addClass': '_removeClass'\n    const classes = this.classes\n\n    this[method](this.selector, classes.alignLeft)\n\n    this.options.align = position\n\n    /**\n     * This event is fired when the Menu has changed align position.\n     *\n     * @event StackedMenu#menu:align\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:align', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:align', function() {\n     *   console.log('fired on menu:align!!');\n     * });\n     */\n    this._emit('menu:align')\n\n    return this\n  }\n\n  /**\n   * Determine whether the Menu is currently compact.\n   * @public\n   * @return {Boolean} is compact.\n   *\n   * @example\n   * var isCompact = menu.isCompact();\n   */\n  isCompact() {\n    return this.options.compact\n  }\n\n  /**\n   * Toggle the Menu compact mode.\n   * @public\n   * @fires StackedMenu#menu:compact\n   * @param  {Boolean} isCompact - The compact mode.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.compact(true);\n   */\n  compact(isCompact) {\n    const method = (isCompact) ? '_addClass': '_removeClass'\n    const classes = this.classes\n\n    this[method](this.selector, classes.compact)\n\n    this.options.compact = isCompact\n    // reset interactions\n    this._handleInteractions(this.items)\n\n    /**\n     * This event is fired when the Menu has completed toggle compact mode.\n     *\n     * @event StackedMenu#menu:compact\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:compact', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:compact', function() {\n     *   console.log('fired on menu:compact!!');\n     * });\n     */\n    this._emit('menu:compact')\n\n    return this\n  }\n\n  /**\n   * Determine whether the Menu is currently hoverable.\n   * @public\n   * @return {Boolean} is hoverable.\n   *\n   * @example\n   * var isHoverable = menu.isHoverable();\n   */\n  isHoverable() {\n    return this.options.hoverable\n  }\n\n  /**\n   * Toggle the Menu (interaction) hoverable.\n   * @public\n   * @fires StackedMenu#menu:hoverable\n   * @param  {Boolean} isHoverable - `true` for hoverable and `false` for collapsible (clickable).\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.hoverable(true);\n   */\n  hoverable(isHoverable) {\n    const classes = this.classes\n\n    if (isHoverable) {\n      this._addClass(this.selector, classes.hoverable)\n      this._removeClass(this.selector, classes.collapsible)\n    } else {\n      this._addClass(this.selector, classes.collapsible)\n      this._removeClass(this.selector, classes.hoverable)\n    }\n\n    this.options.hoverable = isHoverable\n    // reset interactions\n    this._handleInteractions(this.items)\n\n    /**\n     * This event is fired when the Menu has completed toggle hoverable.\n     *\n     * @event StackedMenu#menu:hoverable\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:hoverable', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:hoverable', function() {\n     *   console.log('fired on menu:hoverable!!');\n     * });\n     */\n    this._emit('menu:hoverable')\n\n    return this\n  }\n}\n\nexport default StackedMenu\n"],"names":["StackedMenu","options","this","compact","hoverable","closeOther","align","selector","selectorClass","_extend","document","querySelector","items","querySelectorAll","Array","prototype","forEach","cb","arg","TypeError","let","array","i","length","call","each","classes","alignLeft","collapsible","hasChild","hasActive","hasOpen","active","open","handlerClickDoc","handlerOver","handlerOut","handlerClick","init","_onReady","handler","readyState","addEventListener","obj","args","arguments","key","hasOwnProperty","_emit","type","data","e","createEvent","initEvent","createEventObject","eventType","eventName","dispatchEvent","fireEvent","_hover","el","tagName","_on","types","split","window","_off","removeEventListener","_addClass","className","classList","add","_removeClass","remove","replace","RegExp","join","_hasClass","contains","test","_hasChild","_hasActive","_hasOpen","_isLevelMenu","parentNode","_menuTrigger","index","elHover","openMenu","bind","closeMenu","toggleMenu","isHoverable","_handleInteractions","const","self","_getSubhead","textContent","_generateSubhead","link","menu","subhead","label","menus","children","child","cc","nextElementSibling","createElement","createTextNode","appendChild","insertBefore","firstChild","_handleTabIndex","container","setAttribute","removeAttribute","_slide","direction","speed","easing","es","getComputedStyle","walkSpeed","clearSpeed","style","transition","overflow","height","visibility","opacity","setTimeout","done","Promise","resolve","opts","stopPropagation","preventDefault","body","isCompact","closeAllMenu","emiter","blockedSlide","then","push","clientHeight","documentElement","pos","getBoundingClientRect","tolerance","bottom","top","transformOriginX","transformOrigin","v","splice","itemParent","elParent","method","item","position"],"mappings":"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"}